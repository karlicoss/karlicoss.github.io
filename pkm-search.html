<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Icon made by Twitter -->
        <!-- https://twemoji.twitter.com/content/twemoji-twitter/en.html -->
        <link rel="icon" href="./robot-face.png">
        <link rel="apple-touch-icon" href="./robot-face.png">

        <meta name="generator" content="hakyll">
        <meta name="language" content="English">
        
        <meta name="keywords" content="pkm search emacs orgmode">
        
        <!-- TODO concat with keywords tags; also need to make comma separated? -->

        <title>Building personal search infrastructure for your knowledge and code | Mildly entertainingᵝ</title>

        <link href="https://fonts.googleapis.com/css?family=Source+Serif+Pro" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="./css/default.css?v=3" />
        <!-- TODO make conditional?? -->
        <link rel="stylesheet" href="./css/posts-list.css" /> 
        <link rel="stylesheet" href="./css/links.css?v=4" />

        
    </head>
    <body>
        <header>
            <nav>
                <span class="nav-left">
                    <a class="fat" href="./">Home</a>
                    <!-- TODO eh, not sure if this symbol is good for that... -->
                    ·
                    <a class="fat" href="./ideas.html">Ideas</a>
                    ·
                    <a class="fat" href="./notes.html">Notes</a>
                    ·
                    <a class="fat" href="./tags.html">Tags</a>
                </span>
                <span class="nav-right">
                    <a class="fat" href="./feed.html">Feed</a>
                    ·
                    <a class="fat" href="./site.html">Site</a>
                    ·
                    <a class="fat" href="./me.html">Me</a>
                </span>
            </nav>
        </header>

        <main>
            

<!-- <link rel="stylesheet" href="/css/org.css" /> -->

<link rel="stylesheet" href="./css/htmlize.css" />
<link rel="stylesheet" href="./css/org-default.css" />

<link rel="stylesheet" href="./css/org-extra.css?v=3" />



<article>
    
    <section class="post-title">
    <h1>Building personal search infrastructure for your knowledge and code</h1>
    <div class="summary">Overview of search tools for desktop and mobile; using Emacs and Ripgrep as desktop search engine</h2>
    </section>
    <!-- are sections appropriate for that? -->

    <section class="content">
    <div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#why">1. Why search?</a></li>
<li><a href="#what">2. What do I search?</a></li>
<li><a href="#personal_information">3. Searching in personal information</a>
<ul>
<li><a href="#org_mode">Org mode notes</a></li>
<li><a href="#other">Other plaintext, chats and social media</a></li>
</ul>
</li>
<li><a href="#recoll">4. Recoll</a></li>
<li><a href="#android">5. Searching on Android</a>
<ul>
<li><a href="#org0000009">Orgzly</a></li>
<li><a href="#org000000a">Docsearch +</a></li>
<li><a href="#recoll_web">Recoll Web</a></li>
</ul>
</li>
<li><a href="#web">6. Web search</a>
<ul>
<li><a href="#org000000d">Firefox enhancements</a></li>
<li><a href="#org000000e">Chrome enhancements</a></li>
</ul>
</li>
<li><a href="#code">7. Searching in code</a>
<ul>
<li><a href="#org0000010">Why?</a></li>
<li><a href="#org0000011">What do I want</a></li>
<li><a href="#org0000012">Existing code search tools</a></li>
<li><a href="#org0000014">Solution: use Emacs and Ripgrep</a></li>
</ul>
</li>
<li><a href="#appendix_cloudmacs">8. Appendix: searching away from computer</a></li>
<li><a href="#appendix_daemon">9. Appendix: Lightning fast Emacs</a>
<ul>
<li><a href="#org0000017">running daemon on startup</a></li>
</ul>
</li>
<li><a href="#appendix_emacs">10. Appending: general Emacs tips</a></li>
<li><a href="#future">11. Future and my holy grail of search</a></li>
<li><a href="#org000001b">12. --</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org0000000">
<h2 id="why"><a class="headerlink" href="#why">¶</a><span class="section-number-2">1</span> Why search?</h2>
<div class="outline-text-2" id="text-why">
<div><span class="before-aside">
Having information in the digital form, collecting and writing notes is incredibly valuable.
Our brains are good at associations, pattern matching and creative thinking, not storing arrays of structured data, and external memory is one of the main thinking hacks computers aid us with. 
</span><aside class="sidenote">see <a class="post-tag" href="./tags.html#extendedmind">#extendedmind</a></aside></div>
<p>
However this information is not so useful if you can't access and search it quickly.
Instant search changes the way you think. Ever got sense of flow while working through some problem, and trying different things from Stackoverflow or documentation?
</p>
<p>
These days, if you have decent connection, you are seconds away from finding almost any public knowledge in the internet.
However, there is another aspect of information: personal and specific to <i>your</i> needs, work and hobbies.
It's <i>your</i> todo list, <i>your</i> private notes, books <i>you</i> are reading. Of course, it's not that well integrated with the outside world, hence the tooling and experience of interacting with it is very different.
</p>
<p>
Some examples:
</p>
<ul class="org-ul">
<li><div><span class="before-aside">
To find something from <i>my</i> Messenger history with a friend, I need to be online, open Facebook, navigate to search and use the interface Facebook's employees thought convenient (spoiler: it sucks) 
</span><aside class="sidenote"><a class="post-tag" href="./tags.html#offline">#offline</a></aside></div>
<p>
It's <i>my</i> information, something that came out from my brain. Why can't I have it available anywhere, anytime, presented the way I prefer?
</p></li>
<li><p>
To find something in <i>my</i> Kobo ebook, I need to reach my device physically and type the query using the virtual keyboard (yep, e-ink lag!). Not a very pleasant experience.
</p>
<p>
It's something <i>I</i> own and have read. Why does it have to be so hard?
</p></li>
</ul>
<p>
Such things are pretty frustrating to me, so I've been working on making them easier. Search has to be <a href="https://en.wikipedia.org/wiki/Incremental_search">incremental</a>, fast and as convenient to use as possible.
I'll be sharing some of workflows, tricks and thoughts in this post.
</p>
<p>
The post is geared towards using Emacs and Org-mode, but hopefully you'll find some useful tricks for your current tools and workflow even if you don't.
There is (almost) nothing inherently special about Emacs, I'm sure you can achieve similar workflows in other modern text editors given they are flexible enough.
</p>
<p>
Note: throughout the post I will link to my <a href="https://github.com/karlicoss/dotfiles-emacs">emacs config</a> snippets. 
To prevent code references from staling, I use permalinks, but check master branch as well in case of patches or more comments in code.
</p>
</div>
</div>
<div class="outline-2" id="outline-container-org0000001">
<h2 id="what"><a class="headerlink" href="#what">¶</a><span class="section-number-2">2</span> What do I search?</h2>
<div class="outline-text-2" id="text-what">
<p>
I'll write about searching in
</p>
<ul class="org-ul">
<li>my personal notes, tasks and knowledge repository (this blog included)</li>
<li>all digital trace I'm leaving (tweets, internet comments, annotations)</li>
<li>chat logs with people</li>
<li>books and papers I'm reading</li>
<li>code that I'm working on</li>
<li>information on the Internet (duh!)</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org0000007">
<h2 id="personal_information"><a class="headerlink" href="#personal_information">¶</a><span class="section-number-2">3</span> Searching in personal information</h2>
<div class="outline-text-2" id="text-personal_information">
<p>
By personal information I refer to things like todo list, personal wiki or whatever you use to store information relevant to your life.
</p>
</div>
<div class="outline-3" id="outline-container-org0000003">
<h3 id="org_mode"><a class="headerlink" href="#org_mode">¶</a>Org mode notes</h3>
<div class="outline-text-3" id="text-org_mode">
<p>
For the most part, I keep things in Org mode, and I use Emacs to work with it. Apart from regular means of plaintext search (I'll write about it <a class="link-down" href="#other">later</a>), for me it's important to search over tags:
</p>
<ul class="org-ul">
<li><a href="https://orgmode.org/manual/Matching-tags-and-properties.html"><code class="inline">org-tags-view</code></a> is available by default and an easy way to run simple tag searches</li>
<li><p>
<a href="https://github.com/alphapapa/org-ql#screenshots">org-ql</a>
</p>
<p>
It's a relatively new package, with new query syntax as the main feature, which is much easier to use and remember than builtin Org query syntax: <a href="https://github.com/alphapapa/org-ql#comparison-with-org-agenda-searches">comparison</a>.
</p>
<p>
I mainly use these commands:
</p>
<ul class="org-ul">
<li><a href="https://github.com/alphapapa/org-ql#helm-org-ql"><code class="inline">helm-org-ql</code></a> for <b>incremental</b> search in the current buffer</li>
<li><a href="https://github.com/alphapapa/org-ql#org-ql-search"><code class="inline">org-ql-search</code></a> <b>interactively</b> prompts you for the search target, sort and grouping</li>
</ul></li>
</ul>
<p>
Another notable mention is <a href="https://github.com/alphapapa/org-rifle#screenshots">org-rifle</a>, which is an entry based search, presenting headings along with the matched content in Helm buffer.
However as the author <a href="https://github.com/alphapapa/org-rifle/issues/42#issuecomment-544114082">mentioned</a> it might be obsoleted by org-ql soon. 
</p>
<p>
Here are some typical workflows with my org-mode:
</p>
<ul class="org-ul">
<li><p>
<a id="org0000002"></a> tags for friends
</p>
<p>
I see an interesting article or think of something which would be good to share with a friend, but at the moment it's not quite a good time to send it.  I can just capture it and attach a tag (e.g. <samp class="inline">ann</samp> or <samp class="inline">jeremy</samp>). That way next time we chat I can just look up things under their tag and send them.
</p>
<p>
It works the other way around as well: imagine they sent me a link or asked me to do something, but I can't do it immediately. I have a special script that converts chat messages into todo items and automatically attaches the corresponding tag. I write more about it <a href="orger-todos.html#telegram2org">here</a>.
</p></li>
<li><p>
assembling blog posts
</p>
<p>
Unfortunately, I can't just sit and write comprehensible texts without preparation.
Typically I have thoughts on the topic now and then, which I just note down and mark with the tag.
When I feel it's time to prepare the post, I can just search by the tag (e.g. <code class="inline">tags:search</code> for this post), and refile the items into the file with the post draft.
</p></li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-org0000006">
<h3 id="other"><a class="headerlink" href="#other">¶</a>Other plaintext, chats and social media</h3>
<div class="outline-text-3" id="text-other">
<p>
As I mentioned, I find having to switch to the browser, wait till the website loads and cope with crappy search implementations very distracting and frustrating.
</p>
<p>
What is more, often you don't even remember whether exactly you were discussing something: on Telegram or Facebook or Reddit? So having a single point of entry to your information and unified search over all of your stuff is extremely helpful.
</p>
<p>
For instant messaging, I'm using plaintext mirrors, so chat history is always available in plaintext on my computers:
</p>
<ul class="org-ul">
<li><a href="https://github.com/karlicoss/telegram-backup-to-txt">Telegram messages</a>
Didn't bother with org-mode because files would be too huge and there isn't much structure anyway.</li>
<li><a href="https://github.com/Totktonada/vk_messages_backup">Vkontakte messages</a>
Sadly export tool stopped working because of API restrictions, but I'm not using VK much anymore either. At least I got historic messages.</li>
</ul>
<p>
Most services where I can comment, write or leave annotation, I'm mirroring as org-mode.
I write about it in detail here: <a href="orger.html">part I</a>, <a href="orger-todos.html">part II</a>.
</p>
<p>
That gives me source data for a search engine over anything I've ever:
</p>
<ul class="org-ul">
<li>tweeted</li>
<li>bookmarked on Pinboard</li>
<li>highlighted in Instapaper or Kobo</li>
<li>saved or upvoted on Reddit</li>
<li>etc., etc.</li>
</ul>
<p>
All these files are either non-Org or somewhat heavy for structured Org-mode search. In addition, I have many old files from my pre-orgmode era when I was using Gitit or Zim.
</p>
<p>
To search over them, I'm using Emacs and Ripgrep (you can read why <a class="link-down" href="#org0000004">later</a>):
</p>
<p>
<a href="https://github.com/karlicoss/dotfiles-emacs/blob/4ea7a8deb48403cea712f1bd48b553b465da05f4/.spacemacs.d/config.el#L130-L134"><code class="inline">my/search</code></a>
runs ripgrep against <code class="inline">my/search-targets</code> variable contains paths to notes, chat logs, Orger outputs etc.
</p>
<p>
The interesting bit about <code class="inline">my/search</code> is <a href="https://github.com/karlicoss/dotfiles-emacs/blob/4ea7a8deb48403cea712f1bd48b553b465da05f4/.spacemacs.d/config.el#L87-L127"><code class="inline">--my/one-off-helm-follow-mode</code></a> call. It's a somewhat horrible hack that  automatically enables helm-follow mode so you don't have to press <code class="inline">C-c C-f</code> every time you invoke helm.
</p>
<p>
Finally, to make sure I can invoke search in an instance, I'm using a <a class="link-down" href="#org0000005">global keybinding</a>.
</p>
<p>
Here's a <b>demo</b> <a href="https://file.globalupload.io/wu7HYYyJaY.gif">gif (5Mb)</a> of using this to search 'greg egan' in my knowledge repository.
You can see that as a result, I'm getting my Kobo highlights (<samp class="inline">kobo.org</samp>), my reading list (<samp class="inline">read.org</samp>) and even some video (<samp class="inline">youtube.org</samp>)!
</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org0000008">
<h2 id="recoll"><a class="headerlink" href="#recoll">¶</a><span class="section-number-2">4</span> Recoll</h2>
<div class="outline-text-2" id="text-recoll">
<p>
Recoll is an indexer that runs as daemon (or a regular cron job) and a full text search tool.
</p>
<p>
It supports many <a href="https://www.lesbonscomptes.com/recoll/features.html">formats and other features</a>, so I suggest checking them out for yourself.
</p>
<p>
Even though I index all my documents, I find it quicker to run grep I described above to search in plaintext. 
So for me, Recoll is mostly for searching and quickly jumping to results in <b>PDFs and EPUBs</b> (see <a href="https://www.lesbonscomptes.com/recoll/pics/recoll-pdf-snippets.html">screenshot</a>).
</p>
<p>
There is <a href="https://github.com/emacs-helm/helm-recoll">helm-recoll</a> Emacs module, but I found it a bit awkward to use, and Recoll GUI feels significantly superior.
Basically only thing helm-recoll does is presenting you list of filenames that match your query.
It feels that it should be straightforward to modify the module and integrate abstract, snippets and other things you can query Recoll for.
</p>
<p>
Considering I don't need use Recoll it too often, I just gave up on helm-recoll and using GUI.
</p>
<p>
I'm also running a <a href="https://github.com/koniu/recoll-webui">Web UI</a> on my VPS, so I can use it from my phone, or potentially from other computers.
</p>
<p>
Recoll's distinguishing features are proper <a href="https://www.lesbonscomptes.com/recoll/usermanual/webhelp/docs/RCL.SEARCH.LANG.html">search query language</a>
and <a href="https://www.lesbonscomptes.com/recoll/usermanual/webhelp/docs/RCL.INDEXING.MONITOR.html">realtime, inotify based indexing</a>.
I don't have that much data yet to benefit massively from proper search queries, but I can see that it could be potentially useful in future as amount of personal data grows.
</p>
</div>
</div>
<div class="outline-2" id="outline-container-org000000c">
<h2 id="android"><a class="headerlink" href="#android">¶</a><span class="section-number-2">5</span> Searching on Android</h2>
<div class="outline-text-2" id="text-android">
<p>
Most of my notes and knowledge repository are plaintext, so it is easily and continuously shared on my phone via Dropbox/Syncthing.
</p>
<p>
Since using Emacs on Android is hardly a meaningful experience, I'm working around it by using other apps.
</p>
</div>
<div class="outline-3" id="outline-container-org0000009">
<h3 id="org0000009"><a class="headerlink" href="#org0000009">¶</a><a href="https://github.com/orgzly/orgzly-android">Orgzly</a></h3>
<div class="outline-text-3" id="text-org0000009">
<p>
I can't recommend it enough, it's got many things done right, very fast and the code is extremely readable and well tested so it's easy to contribute.
</p>
<p>
It has its own small <a href="http://www.orgzly.com/help#search">query language</a> (at the time <a href="https://github.com/alphapapa/org-ql">org-ql</a> didn't exist).
</p>
<p>
You can save <a href="https://lh3.googleusercontent.com/FweBE2T3T3wZwJC64DQgtGj8vv8jKPBGTClnRAApSOHdKq4hiFdpq_JjEBPsMj_nTDA=w2560-h1295">search queries</a>, which ends up being pretty similar to custom Org-mode <b><b>agendas</b></b>.
Searches can be displayed as persistent widgets, e.g. I find convenient to have a phone screen dedicated to 'Buy' search (<code class="inline">t.buy</code> query) or 'Do at work' search (<code class="inline">t.@work</code> query).
</p>
<p>
As I described <a class="link-up" href="#org0000002">above</a>, I keep few saved search queries for some friends so I can recall what I wanted to discuss with them.
</p>
</div>
</div>
<div class="outline-3" id="outline-container-org000000a">
<h3 id="org000000a"><a class="headerlink" href="#org000000a">¶</a><a href="https://play.google.com/store/apps/details?id=com.docsearch.pro">Docsearch +</a></h3>
<div class="outline-text-3" id="text-org000000a">
<p>
Docsearch is a not very well-known tool (e.g. zero search results on Reddit or Twitter), but I don't know any alternatives for it.
</p>
<p>
It's a fulltext indexing and search app for plaintext files, but apparently it even supports EPUBs and PDFs.
<a href="https://lh3.googleusercontent.com/psPhmFoawEzwZQpwBGgVz42ojnR-uAi70Li4DBc4Z13wLOTannvT2suaxZQA9YX_Bg=w2560-h1295">Here's</a> how matches list looks. Screenshots on Google Play give a pretty good idea what the app does.
</p>
<p>
I find it convenient for quick search over things that are not imported in Orgzly, e.g. <samp class="inline">.txt</samp> chat logs (Telegram, VK) and huge org-mode files
I described <a class="link-up" href="#other">above</a>.
</p>
<p>
It's a bit backwards in terms of UI (even though I like that it's compact and functional), but main downside is it's not opensource.
I'd be extremely happy to replace this with some open source application, so please let me know if you know one!
</p>
</div>
</div>
<div class="outline-3" id="outline-container-org000000b">
<h3 id="recoll_web"><a class="headerlink" href="#recoll_web">¶</a>Recoll Web</h3>
<div class="outline-text-3" id="text-recoll_web">
<p>
On the rare occasions when I need to search in pdfs or books (which I don't sync on my phone) , I just use Recoll <a href="https://github.com/koniu/recoll-webui">Web UI</a> that I'm selfhosting.
</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org000000f">
<h2 id="web"><a class="headerlink" href="#web">¶</a><span class="section-number-2">6</span> Web search</h2>
<div class="outline-text-2" id="text-web">
<p>
If you're reading this at all, chances you're quite good at using web search already. <a href="https://www.gwern.net/Search#search">Gwern</a> got a good writeup on the subject.
</p>
<p>
Knowing how to compose a search query is one thing, but navigating to the service, waiting till it loads, moving to searchbox takes precious time. Many people forget about <a href="https://www.howtogeek.com/114176/how-to-easily-create-search-plugins-add-any-search-engine-to-your-browser">custom search engines</a>. Here are ones I'm using:
</p>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left" />
<col class="org-left" />
<col class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">g</td>
<td class="org-left">Google</td>
<td class="org-left"><samp class="inline">https://www.google.com/complete/search?client=firefox&amp;q={searchTerms}</samp></td>
</tr>
<tr>
<td class="org-left">d</td>
<td class="org-left">DuckDuckGo</td>
<td class="org-left"><samp class="inline">https://duckduckgo.com/?q={searchTerms}&amp;t=canonical</samp></td>
</tr>
<tr>
<td class="org-left">r</td>
<td class="org-left">Reddit</td>
<td class="org-left"><samp class="inline">https://www.reddit.com/search?q={searchTerms}</samp></td>
</tr>
<tr>
<td class="org-left">gh</td>
<td class="org-left">GitHub</td>
<td class="org-left"><samp class="inline">https://github.com/search?q={searchTerms}&amp;ref=opensearch</samp></td>
</tr>
<tr>
<td class="org-left">pin</td>
<td class="org-left">Pinboard: search all</td>
<td class="org-left"><samp class="inline">https://pinboard.in/search/?query={searchTerms}r&amp;all=Search+All</samp></td>
</tr>
<tr>
<td class="org-left">tw</td>
<td class="org-left">Twitter</td>
<td class="org-left"><samp class="inline">https://twitter.com/search</samp></td>
</tr>
<tr>
<td class="org-left">y</td>
<td class="org-left">YouTube</td>
<td class="org-left"><samp class="inline">https://www.youtube.com/results?search_query={searchTerms}&amp;page={startPage?}&amp;utm_source=opensearch</samp></td>
</tr>
<tr>
<td class="org-left">m</td>
<td class="org-left">Google Maps</td>
<td class="org-left"><samp class="inline">https://www.google.com/maps/search/{searchTerms}?hl=en&amp;source=opensearch</samp></td>
</tr>
<tr>
<td class="org-left">w</td>
<td class="org-left">Wikipedia (en)</td>
<td class="org-left"><samp class="inline">https://en.wikipedia.org/wiki/Special:Search</samp></td>
</tr>
<tr>
<td class="org-left">cpp</td>
<td class="org-left">Cppreference</td>
<td class="org-left"><samp class="inline">https://en.cppreference.com/mwiki/index.php?search={searchTerms}</samp></td>
</tr>
<tr>
<td class="org-left">js</td>
<td class="org-left">MDN</td>
<td class="org-left"><samp class="inline">https://developer.mozilla.org/en-US/search?q={searchTerms}</samp></td>
</tr>
<tr>
<td class="org-left">eb</td>
<td class="org-left">Ebay</td>
<td class="org-left"><samp class="inline">https://www.ebay.co.uk/sch/i.html?_nkw={searchTerms}</samp></td>
</tr>
<tr>
<td class="org-left">am</td>
<td class="org-left">Amazon.co.uk</td>
<td class="org-left"><samp class="inline">https://www.amazon.co.uk/exec/obidos/external-search/</samp></td>
</tr>
<tr>
<td class="org-left">tru</td>
<td class="org-left">Translate en-ru</td>
<td class="org-left"><samp class="inline">https://translate.google.com/#view=home&amp;op=translate&amp;sl=en&amp;tl=ru&amp;text={searchTerms}</samp></td>
</tr>
<tr>
<td class="org-left">tde</td>
<td class="org-left">Translate en-de</td>
<td class="org-left"><samp class="inline">https://translate.google.com/#view=home&amp;op=translate&amp;sl=en&amp;tl=de&amp;text={searchTerms}</samp></td>
</tr>
<tr>
<td class="org-left">dd</td>
<td class="org-left">DevDocs</td>
<td class="org-left"><samp class="inline">https://devdocs.io/#q={searchTerms}</samp></td>
</tr>
</tbody>
</table>
<p>
Some of these obvious, some deserve separate mention:
</p>
<ul class="org-ul">
<li><p>
reddit contains vast amounts of (somewhat curated) human knowledge
</p>
<p>
Google search often gives dubious and not very meaningful results on certain topics (e.g. product reviews, exercise, dieting).
On reddit, you'd at least find real people sharing their <b>honest and real opinions</b>.
Chances are that if a link is good, you would find it on  on reddit anyway.
</p></li>
<li><p>
twitter is similar: there is certainly more spam there, but sometimes it's interesting to type a link or blog post title in twitter search to see how <b>real people reacted</b>. 
</p>
<p>
That has limited utility, e.g. doesn't work with politicized content, but if the topic of interest is rare, could be very useful.
</p></li>
<li><a href="https://pinboard.in">pinboard</a> is an awesome source of curated content as well</li>
</ul>
<p>
Next, I find it very convenient to have some code documentation available locally.
First, it helps when you're on wonky internet or just offline for whatever reason.
Second, it's feels <b>really fast</b>, even if you're on fiber.
</p>
<p>
Here's what I'm using for that:
</p>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left" />
<col class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">py</td>
<td class="org-left"><samp class="inline">file:///usr/share/doc/python3/html/search.html?q=%s</samp></td>
</tr>
<tr>
<td class="org-left">rust</td>
<td class="org-left"><samp class="inline">file:///home/karlicos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/share/doc/rust/html/std/option/index.html?search=%s</samp></td>
</tr>
</tbody>
</table>
<p>
Sadly, the extension mentioned above doesn't work with <samp class="inline">file://</samp> schema for some reason, so to add it in Firefox,
you can use the method described <a href="https://superuser.com/a/7336/300795">here</a>, it's as easy as adding a bookmark.
</p>
<p>
Recently I ran into <a href="https://devdocs.io/offline">devdocs.io</a>, it's using your browser's <b>offline</b> storage to cache the documentation.
I'm still getting used to it, but it's amazing how faster it is than jumping to documentation online. You can use it with multiple languages, you just type the search engine prefix first, and then language prefix (e.g. <code class="inline">dd cpp emplace_back</code>).
</p>
<p>
Finally, it may be convenient to set up <a href="https://github.com/hrs/engine-mode">engine-mode</a> in Emacs, or <a href="https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Bweb-services/search-engine">search-engine layer</a> in Spacemacs. It lets you invoke a browser search directly from Emacs (e.g. <code class="inline">SPC s G</code> to do google search). I find it convenient when I need to search many things in bulk.
</p>
</div>
<div class="outline-3" id="outline-container-org000000d">
<h3 id="org000000d"><a class="headerlink" href="#org000000d">¶</a>Firefox enhancements</h3>
<div class="outline-text-3" id="text-org000000d">
<p>
I find it convenient to enable <a href="https://www.ghacks.net/2016/06/11/firefox-page-search-improvements">'highlight all'</a> for search within a page.
</p>
</div>
</div>
<div class="outline-3" id="outline-container-org000000e">
<h3 id="org000000e"><a class="headerlink" href="#org000000e">¶</a>Chrome enhancements</h3>
<div class="outline-text-3" id="text-org000000e">
<p>
When I used Chrome, one thing that annoyed me was that it populates search engines automatically, and <a href="https://support.google.com/chrome/forum/AAAAP1KN0B0DOS1J_u6N8I">there is not way to disable it</a>.
</p>
<p>
There is a nice open source <a href="https://chrome.google.com/webstore/detail/dont-add-custom-search-en/dnodlcololidkjgbpeoleabmkocdhacc">extension</a> that prevents Chrome from doing it.
</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org0000015">
<h2 id="code"><a class="headerlink" href="#code">¶</a><span class="section-number-2">7</span> Searching in code</h2>
<div class="outline-text-2" id="text-code">
<p>
TLDR: I tried different existing code search tools, was disappointed and ended up using Emacs + Ripgrep.  
</p>
</div>
<div class="outline-3" id="outline-container-org0000010">
<h3 id="org0000010"><a class="headerlink" href="#org0000010">¶</a>Why?</h3>
<div class="outline-text-3" id="text-org0000010">
<p>
I've got lots of personal projects, experiments, data processing and backup scripts on my computer.
I also tend to create a git repository at a slightest opportunity primarily as a means of code backup/rollback and progress tracking, but often it results in actual projects, so I would need a repository anyway.
Naturally, these repositories end up scattered across the whole filesystem, making it tricky to remember where I've put the code or that it even existed in the first place.
</p>
<p>
It's very convenient to have some sort of code search engine if you're in a similar situation to mine for multiple reasons:
</p>
<ul class="org-ul">
<li><p>
Doing potentially breaking code changes
</p>
<p>
For instance, I want to remove some unused function or refactor something in <a href="https://github.com/karlicoss/my"><code class="inline">my</code></a> package, which is a Python library to access my personal data.
It's used in lots of scripts or dashboards that run in Cron every day.
</p>
<p>
I could just go for it, remove the function and hope nothing fails, but if it does then I'd have to deal with fixing it again.
It's frustrating and I'd rather search for function usages in all of my code and make sure it's actually safe to remove.
</p></li>
<li><p>
Reusing code snippets and tricks
</p>
<p>
When you're getting familiar to some new library or framework, you often end up googling how to solve problems twice.
Sometimes you remember solving the problem you've already had, but don't quite recall where. 
</p>
<p>
For instance for me, such library is <a href="https://docs.sqlalchemy.org/en/13/core">Sqlalchemy</a>.
It's very convenient for handling databases, but I only need it infrequently, so can never remember how to work with it.
Reading documentation all over again is not very helpful because I've got very few usecases and queries that are specific to my purposes.
</p>
<p>
If I can search for <code class="inline">sqlalchemy</code> in my code, it shows every repository where I used it so I can quickly copy bit of code I'm interested at.
</p></li>
<li><p>
Forgotten code
</p>
<p>
It happens that I remember writing code for some purpose, but don't quite recall where I put it.
Even if you keep all your repos in the same location, you might forget how you named it.
</p>
<p>
Full text search, however, allows to find it if you remember some comments or class/function names.
</p></li>
<li><p>
Help and documentation
</p>
<p>
However good is library's documentation, sometimes it just isn't covering your typical needs. If you're a power user, docs are almost never enough and you end up reading the code to bend the library into doing what you want.
</p>
<p>
For me such libraries are <a href="https://code.orgmode.org/bzg/org-mode">Org mode</a> or <a href="https://github.com/jaspervdj/hakyll">Hakyll</a>, so I often had to search in their code on Github.
Searching on Github however is quite awkward. It's slow, it's not incremental and lacks navigation.
</p>
<p>
If I have a local clone of the repository on my disk, I can search over it in an instant (without having it opened in the first place) and use familiar tools (e.g. IDE) for navigation.
</p></li>
</ul>
<p>
At the time, I was just using recursive <code class="inline">grep</code> and then opening some of results in vim to refine.
That's a pretty pathetic workflow. 
</p>
</div>
</div>
<div class="outline-3" id="outline-container-org0000011">
<h3 id="org0000011"><a class="headerlink" href="#org0000011">¶</a>What do I want</h3>
<div class="outline-text-3" id="text-org0000011">
<p>
My ideal code search tool would:
</p>
<ul class="org-ul">
<li><p>
run against code on my filesystem
</p>
<p>
Just any source files, so it wouldn't have to fetch repositories from Github and keep them somewhere separately.
</p></li>
<li><p>
realtime indexing 
</p>
<p>
Ideally, inotify-based, but any means of refreshing search index without having to commit first would be nice.
</p></li>
<li>semantic search in definitions/variables etc with fallback to simple search if the language isn't supported</li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-org0000012">
<h3 id="org0000012"><a class="headerlink" href="#org0000012">¶</a>Existing code search tools</h3>
<div class="outline-text-3" id="text-org0000012">
<p>
So, I wanted some code search and indexing tool that could watch over all the source file on my filesystem and let me search through them.
</p>
<p>
It sounds as a fairly straightforward wish, but to my surprise, none of existing projects I found and tried do the job:
</p>
<ul class="org-ul">
<li><p>
<a href="https://github.com/sourcegraph/sourcegraph">Sourcegraph</a>
</p>
<p>
Lets you index Github/Bitbucket/Gitlab repos etc, but the process for adding local repositories <a href="https://docs.sourcegraph.com/admin/repo/add_from_local_disk">is extremely tedious</a>.
Also apparently, it clones repositories first so it's not exactly realtime indexing.
</p>
<p>
Overall, I feel that it only makes sense for companies that use few monorepos.
</p></li>
<li><a href="https://oracle.github.io/opengrok">OpenGrok</a>: <a href="https://github.com/oracle/opengrok/wiki/How-to-setup-OpenGrok">setup</a> looks extremely heavy, doesn't support realtime search in arbitrary paths</li>
<li><a href="https://github.com/hound-search/hound">Hound</a>: <a href="https://github.com/hound-search/hound/issues/83">doesn't support</a> recursive repository discovery.</li>
<li><a href="https://github.com/google/zoekt">zoekt</a>: manual is pretty confusing and also looks tailored for huge standalone repos</li>
<li><a href="https://livegrep.com">Livegrep</a>: tailored to huge monorepos (see <a href="https://news.ycombinator.com/item?id=3869880">HN discussion</a>)</li>
</ul>
<p>
As you can see, none of these are convenient for searching in personal code.
</p>
</div>
</div>
<div class="outline-3" id="outline-container-org0000014">
<h3 id="org0000014"><a class="headerlink" href="#org0000014">¶</a>Solution: use Emacs and Ripgrep</h3>
<div class="outline-text-3" id="text-org0000014">
<p>
Disappointed, I figured that least I could do is at somehow improve my workflow with grep.
</p>
<p>
So, what are the problems with using <code class="inline">grep</code>?
</p>
<ul class="org-ul">
<li>running it against all of code results in false positives. <samp class="inline">node_modules</samp>, minified javascript, etc., you name it
<ul class="org-ul">
<li>you probably want to at least ignore anything that's ignored by <code class="inline">.gitignore</code></li>
</ul></li>
<li>getting bunch of output lines in terminal is not interactive
<ul class="org-ul">
<li>you have to repeat the command to refine the results</li>
<li>you can't quickly navigate to the result, check it and go back</li>
</ul></li>
<li>running it recursively against your filesystem root is ridiculously slow, even if you use an SSD
<ul class="org-ul">
<li>you probably want to restrict your search to directories that look like a project (e.g. repositories), and again, exclude files ignored by version control</li>
</ul></li>
</ul>
<p>
<a id="org0000004"></a>
As it turns out, <code class="inline">ripgrep</code> is the tool!
</p>
<ul class="org-ul">
<li>respects <code class="inline">.gitignore</code> files, so by maintaining <code class="inline">.gitignore</code> properly (e.g. adding <samp class="inline">node_modules/venv</samp> etc) you can make sure you only get <b>meaningful matches</b> when searching for code.</li>
<li>respects <code class="inline">.ignore</code> files. Sometimes code has to be under version control, but you don't want it to show up in search (e.g. could happen if you have vendorized code or minified javascript or static html files).
In that case you can use <code class="inline">.ignore</code> files with the same syntax to exclude certain patterns from ripgrep's reach without messing with <code class="inline">.gitignore</code>.</li>
<li>it's <b>very</b> fast, both by <a href="https://github.com/BurntSushi/ripgrep#quick-examples-comparing-tools">benchmarks</a> and subjective experiments. You can read more comprehensive benchmarks <a href="https://blog.burntsushi.net/ripgrep/#code-search-benchmarks">here</a>.</li>
</ul>
<p>
If you just use ripgrep instead of grep, code search becomes magnitude more pleasant, but it's still not interactive. Long story short, we can use <code class="inline">helm</code> in Emacs to achieve <b>interactivity</b> and incremental search.
</p>
<p>
The only thing that's left is restricting the search to git repositories only.
Ripgrep relies on regexes, so we can't do something like Xpath queries and tell it to only search in directories, that contain <code class="inline">.git</code> directory. I ended up using a two step approach:
</p>
<ul class="org-ul">
<li><p>
first, <a href="https://github.com/karlicoss/dotfiles-emacs/blob/4ea7a8deb48403cea712f1bd48b553b465da05f4/.spacemacs.d/config.el#L75-L83"><code class="inline">my/code-targets</code></a> returns all git repositories it can reach from <code class="inline">my/git-repos-search-root</code>.
</p>
<p>
I'm using <a href="https://github.com/sharkdp/fd"><code class="inline">fd</code></a> to go through the disk and collect all candidate git repositories.
</p>
<p>
Even though fd is already ridiculously <a href="https://github.com/sharkdp/fd#benchmark">fast</a>, this step still takes some time, so I'm caching the repositories. Cache is refreshed in the background every five minutes so we don't have to crawl the filesystem every time. That saves me few seconds on every search.
</p></li>
</ul>
<ul class="org-ul">
<li>then, <a href="https://github.com/karlicoss/dotfiles-emacs/blob/4ea7a8deb48403cea712f1bd48b553b465da05f4/.spacemacs.d/config.el#L136-L140"><code class="inline">my/search-code</code></a> keybindings invokes <code class="inline">ripgrep</code> against all my directories with code, defined in <code class="inline">my/code-targets</code> function.</li>
</ul>
<p>
So, literally running grep against my code turned out to be a pretty good solution. I've got about 350 repositories and it works in a blink. Note, however, that I'm using SSD.
</p>
<p>
Ripgrep searches in real files on my disk, so any changes are reflected <b>immediately</b>, which removes the need for indexing (apart from performance concerns if you've got too many files to search in).
It would still be nice to avoid unnecessary disk operations, and of course, semantic search would be great, and that is definitely going to require some sort of indexer.
</p>
<p>
I've got a <a class="link-down" href="#org0000013">global keybinding</a> to invoke Emacs with a prompt to search in code, so I can do in in a blink.
</p>
<p>
Here's a <a href="https://file.globalupload.io/onCac7sh9M.gif">gif (3.5 Mb)</a> showing it <b>in action</b>: say, I am working on testing a browser extension, and need to interact with in via hotkeys. I remember using <code class="inline">pyautogui</code> for automating <a href="https://github.com/karlicoss/grasp">Grasp</a> tests, but I forgot which function I actually need to use. Searching for 'pyautogui' brings me all the repositories where I'm using it and lets me quickly find out the command I need without having to read the documentation all over again.
</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org0000016">
<h2 id="appendix_cloudmacs"><a class="headerlink" href="#appendix_cloudmacs">¶</a><span class="section-number-2">8</span> Appendix: searching away from computer</h2>
<div class="outline-text-2" id="text-appendix_cloudmacs">
<p>
I'm running Spacemacs on my VPS, so if I'm not near my computer and <a class="link-up" href="#android">phone search</a> doesn't help for some reason, I can still access and search my data. You can read about it <a href="cloudmacs.html">here</a>.
</p>
</div>
</div>
<div class="outline-2" id="outline-container-org0000018">
<h2 id="appendix_daemon"><a class="headerlink" href="#appendix_daemon">¶</a><span class="section-number-2">9</span> Appendix: Lightning fast Emacs</h2>
<div class="outline-text-2" id="text-appendix_daemon">
<p>
As you might have noticed, I'm relying on Emacs as my primary means of interacting with my information, whether it's capturing, accessing or searching.
That means that I want it as fast as possible, in a matter of milliseconds. Seconds spent waiting to launch discourage break your concentration and workflow.
</p>
<p>
Most of the time I've got Emacs window open on one of my desktops anyway, but sometimes it isn't, or I don't want to pollute the current Emacs instance with my search. So I've got a handy helper <a href="https://github.com/karlicoss/dotfiles-emacs/blob/master/bin/gemacsclient">script</a> to quickly invoke persistent Emacs frame for me:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span><span class="org-comment"> -eux</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Wrapper script to invoke interactive emacs commands in a daemon instance.</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">These days many people don't suspect it,</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">but Emacs got server ('emacs' binary) and client ('emacsclient') parts.</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Launching server (i.e. default 'emacs' command) evaluates the config</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">and could potentially take seconds if it's very heavy</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Launching the client however is lightning fast. It's just a matter of creating a window.</span>


<span class="org-variable-name">ARGS</span>=(
 <span class="org-comment-delimiter"># </span><span class="org-comment">This trick gives you best of two worlds: if there is an Emacs daemon running,</span>
 <span class="org-comment-delimiter"># </span><span class="org-comment">it just connects to it. Otherwise, it spawns a daemon first and then connects to it.</span>
 <span class="org-comment-delimiter"># </span><span class="org-comment">Without this setting if you didn't have a daemon running, the command would fail.</span>
 -a <span class="org-string">''</span>

 <span class="org-comment-delimiter"># </span><span class="org-comment">spawn new GUI window, otherwise it tries to launch client in terminal</span>
 --create-frame 
 --frame-parameters=<span class="org-string">"'(fullscreen . maximized)"</span>

 <span class="org-comment-delimiter"># </span><span class="org-comment">process rest of arguments as elisp code</span>
 --eval
  <span class="org-comment-delimiter"># </span><span class="org-comment">bring focus to the window</span>
 <span class="org-string">'(select-frame-set-input-focus (selected-frame))'</span>
)

<span class="org-comment-delimiter"># </span><span class="org-comment">without any extra args it just invokes the daemon instance, otherwise executes the args</span>
<span class="org-keyword">exec</span> emacsclient <span class="org-string">"${ARGS[@]}"</span> <span class="org-sh-escaped-newline">\</span>
                 <span class="org-string">"$@"</span>          <span class="org-comment-delimiter"># </span><span class="org-comment">pass through whatever else you are trying to run</span>
</pre>
</div>
<p>
I've got a global keybinding (<code class="inline">Win+m</code>) that invokes this script. In addition the script accepts a function to call so you can open Emacs with a search prompt, so I have few more handy keybindings:
</p>
<ul class="org-ul">
<li><a id="org0000005"></a> <code class="inline">Win+F1</code> for searching in my <a class="link-up" href="#other">notes and knowledge repository</a></li>
</ul>
<div class="org-src-container">
<pre class="src src-bash"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span><span class="org-comment"> -eux</span>
<span class="org-keyword">exec</span> <span class="org-string">"~/bin/gemacsclient"</span> <span class="org-string">"(spacemacs/defer-until-after-user-config #'my/search)"</span>
</pre>
</div>
<ul class="org-ul">
<li><a id="org0000013"></a> <code class="inline">Win+F3</code> for searching in my repositories</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span><span class="org-comment"> -eux</span>
<span class="org-keyword">exec</span> <span class="org-string">"~/bin/gemacsclient"</span> <span class="org-string">"(spacemacs/defer-until-after-user-config #'my/search-code)"</span>
</pre>
</div>
<ul class="org-ul">
<li><code class="inline">Win+a</code> to open my org-mode agenda</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span><span class="org-comment"> -eux</span>
<span class="org-keyword">exec</span> <span class="org-string">"~/bin/gemacsclient"</span> <span class="org-string">"(spacemacs/defer-until-after-user-config #'my/switch-to-agenda)"</span>
</pre>
</div>
<ul class="org-ul">
<li><code class="inline">Win+c</code> to open org-capture</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span><span class="org-comment"> -eux</span>
<span class="org-keyword">exec</span> <span class="org-string">"~/bin/gemacsclient"</span> <span class="org-string">"(spacemacs/defer-until-after-user-config #'org-capture)"</span>
</pre>
</div>
</div>
<div class="outline-3" id="outline-container-org0000017">
<h3 id="org0000017"><a class="headerlink" href="#org0000017">¶</a>running daemon on startup</h3>
<div class="outline-text-3" id="text-org0000017">
<p>
It might be convenient to always have the daemon running, for that I'm using a systemd unit in <samp class="inline">~/.config/systemd/user/emacs-daemon.service</samp>.
</p>
<div class="org-src-container">
<pre class="src src-bash">[Unit]
<span class="org-variable-name">Description</span>=Emacs daemon

[Service]
<span class="org-variable-name">Type</span>=forking
<span class="org-comment-delimiter"># </span><span class="org-comment">running via bash -l makes it pick up .profile, which sets up PATH etc</span>
<span class="org-variable-name">ExecStart</span>=/bin/bash -l -c <span class="org-string">'/usr/bin/emacs --daemon'</span>
<span class="org-variable-name">ExecStop</span>=/usr/bin/emacsclient --eval <span class="org-string">"(kill-emacs)"</span>
<span class="org-variable-name">Environment</span>=<span class="org-variable-name">SSH_AUTH_SOCK</span>=%t/keyring/ssh
<span class="org-variable-name">Restart</span>=always

[Install]
<span class="org-variable-name">WantedBy</span>=default.target
</pre>
</div>
<p>
It's nothing unusual perhaps apart from using <code class="inline">bash -l</code> so Emacs picks up your <code class="inline">.profile</code> file. Without it, you almost certainly will encounter issues with missing binaries because they would not be in your <code class="inline">PATH</code>.
</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org0000019">
<h2 id="appendix_emacs"><a class="headerlink" href="#appendix_emacs">¶</a><span class="section-number-2">10</span> Appending: general Emacs tips</h2>
<div class="outline-text-2" id="text-appendix_emacs">
<p>
These tips might be pretty obvious, but they belong to this post, so here you go:
</p>
<ul class="org-ul">
<li>if you're on Spacemacs, use <a href="https://github.com/syl20bnr/spacemacs/tree/develop"><code class="inline">develop</code></a> branch. Master is pretty backwards.</li>
<li><p>
search with <code class="inline">ripgrep</code> instead of <code class="inline">grep</code> (not only in Emacs!). It's just <a class="link-up" href="#org0000004">better</a>.
</p>
<p>
In Spacemacs, set up your <code class="inline">init.el</code>:
</p></li>
</ul>
<div class="org-src-container">
<pre class="src src-elisp">dotspacemacs-search-tools '(<span class="org-string">"rg"</span> <span class="org-string">"ag"</span> <span class="org-string">"pt"</span> <span class="org-string">"ack"</span> <span class="org-string">"grep"</span>)

dotspacemacs-additional-packages '(helm-rg)
</pre>
</div>
<ul class="org-ul">
<li><p>
use <a href="https://github.com/emacsorphanage/helm-swoop"><code class="inline">helm-swoop</code></a> for search within the buffer
</p>
<p>
It's easier to watch a <a href="https://raw.githubusercontent.com/ShingoFukuyama/images/master/helm-swoop.gif">demo GIF</a> than to explain.
Swoop opens a Helm window with search result summary and jumps between results in the original buffer as you navigate in helm (<code class="inline">C-j/C-k</code>).
</p>
<p>
I <b><b>highly</b></b> recommend it as a primary way of searching withing a buffer. Bind it it to some convenient combination and get used to it (e.g. mine is <code class="inline">SPC RET</code>).
</p>
<p>
There is also <code class="inline">helm-occur</code>, which has similar functionality, but it seems inferior to swoop.
</p></li>
<li><p>
use <code class="inline">helm-follow-mode</code> (<code class="inline">C-c C-f</code> in Helm buffer) to jump between search results in any Helm search
</p>
<p>
E.g. you can use it with <code class="inline">helm-org-in-buffer-headings</code> as a neat way to navigate within an Org file.
</p></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org000001a">
<h2 id="future"><a class="headerlink" href="#future">¶</a><span class="section-number-2">11</span> Future and my holy grail of search</h2>
<div class="outline-text-2" id="text-future">
<p>
My ultimate goal is to have my 'external' knowledge as highly integrated as possible, as if it was imprinted on my brain neurons. 
</p>
<p>
  Ideally I want to be able to do fulltext realtime search over anything that I ever had in my visual field.
Not even necessarily text, but audio and video as well.
</p>
<p>
That way one wouldn't have to distinguish between different services and mediums of information at all, be it digital or analogue.
</p>
<p>
Technically it's not impossible with the current technology:
</p>
<ul class="org-ul">
<li>I believe that state of OCR is pretty good considering existence of products like google instant translate</li>
<li>speech recognition still sucks in noisy environments, but generally works</li>
<li>object recognition and annotation is still at dawn (I think?), but we'll get there eventually</li>
<li>that would be a lot of data, but potentially lots of it can be filtered out (at least until storage gets really compact and cheap to justify keeping everything)</li>
<li>processing and indexing don't have to be realtime as you can still rely on biological memory and could work overnight on expensive (but not astronomically so?) hardware</li>
<li>plaintext indexes can potentially be stored on your phone and you could have some sort of backend to access visual component</li>
<li>to jump back to the content digital media (like e-books/web pages/information screens) could aid this by supplying QR code or something similar</li>
</ul>
<p>
However each of these is a pretty hard problem and hardly with high demand from people.   
</p>
<p>
Considering Google Glass hasn't made it, the technology is not exactly there, so we have to rely on kludges like the ones I described above.
</p>
</div>
</div>
<div class="outline-2" id="outline-container-org000001b">
<h2 id="org000001b"><a class="headerlink" href="#org000001b">¶</a><span class="section-number-2">12</span> --</h2>
<div class="outline-text-2" id="text-12">
<p>
My closing tips would be:
</p>
<ul class="org-ul">
<li><p>
start simple
</p>
<p>
It's better to have a crappy adhoc script or bash alias that runs <code class="inline">grep</code> over your <samp class="inline">~/notes</samp> directory than no means of searching at all.
</p></li>
<li><p>
keep your things as plaintext as possible
</p>
<p>
This is a somewhat sad advice to give in 2019, but the reality is it's still extremely tedious to work with anything else.
</p></li>
<li><p>
whichever tools you use, make sure they launch in an instant
</p>
<p>
Seconds wasted on waiting break your flow. Better spend time on setting it up once and never think about that later.
</p></li>
<li><p>
give Emacs a try
</p>
<p>
I feel almost sorry advocating Emacs for everything, but despite my disgust at Elisp and frequent frustration, 
it just happens to be superior in terms of bending it to do what you want it to.
</p></li>
</ul>
<p>
As always, I'm open to feedback and would love to hear what is or setup or help you if you're struggling with something!
</p>
</div>
</div>

    </section>

    
    <section class="footer">
        <div class="post-tags"><a class="post-tag" href="./tags.html#pkm">#pkm</a> <a class="post-tag" href="./tags.html#search">#search</a> <a class="post-tag" href="./tags.html#emacs">#emacs</a> <a class="post-tag" href="./tags.html#orgmode">#orgmode</a></div>
        <!-- TODO post-date? -->
        <div class="date">01 November 2019</div>
    </section>
    

    
    <br>
    <div>Discussion:</div>
    <ul>
    
        <li><a href="https://www.reddit.com/r/emacs/comments/dq42vk/building_personal_search_engine_using_emacs_and">/r/emacs</a></li>
    
        <li><a href="https://lobste.rs/s/kzpegk/building_personal_search">lobsters</a></li>
    
        <li><a href="https://irreal.org/blog/?p=8422">irreal</a></li>
    
    </ul>
    

    <section class="comments">
    <script data-isso="https://beepb00p.xyz/comments/" data-isso-reply-to-self="true" src="https://beepb00p.xyz/comments/js/embed.min.js">
</script>

<section id="isso-thread" data-isso-id="isso_pkm_search"></section>

    </section>

</article>

        </main>

        <!-- TODO hmm maybe display something in a footer, so it's clear it's end of content... -->
        
        <footer>
            <span style="float:left">
            <a href="https://twitter.com/karlicoss">🐦 me @twitter</a>
            ·
            <a href="https://github.com/karlicoss">💻 me @github</a>
            </span>

            <a href="http://creativecommons.org/licenses/by/4.0">CC BY 4.0</a>
            
            
        </footer>
    </body>
</html>
